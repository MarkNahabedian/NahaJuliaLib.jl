var documenterSearchIndex = {"docs":
[{"location":"#NahaJuliaLib.jl","page":"Home","title":"NahaJuliaLib.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"NahaJuliaJib is a library of small utilities that I wish Julia had, but, near as I can tell, doesn't yet.","category":"page"},{"location":"#Type-Hierarchy","page":"Home","title":"Type Hierarchy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"allsubtypes\nshowsubtypes\npedigree","category":"page"},{"location":"#NahaJuliaLib.allsubtypes","page":"Home","title":"NahaJuliaLib.allsubtypes","text":"allsubtypes(t::Type)\n\nReturn a Vector of t and all of its subtypes.\n\n\n\n\n\n","category":"function"},{"location":"#NahaJuliaLib.showsubtypes","page":"Home","title":"NahaJuliaLib.showsubtypes","text":"showsubtypes(t::Type) Print a hierarchical list of t and all of its subtypes. \n\n\n\n\n\n","category":"function"},{"location":"#NahaJuliaLib.pedigree","page":"Home","title":"NahaJuliaLib.pedigree","text":"pedigree(t::Type)\n\nReturn a Vector of t and its supertypes.\n\n\n\n\n\n","category":"function"},{"location":"#Defining-Object-Properties","page":"Home","title":"Defining Object Properties","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Rather than use a condirional tree to determine which peoperty is being queried by getproperty, we can method specialize on Val types. We should then be able to automate propertynames based on the defined methods.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A struct might have fields, which are exposed as properties.  The Val methods will not shadow the method that implements that.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@njl_getprop","category":"page"},{"location":"#NahaJuliaLib.@njl_getprop","page":"Home","title":"NahaJuliaLib.@njl_getprop","text":"@njl_getprop MyStruct\n\nDefine the methods necessary so that Val specialized getproperty  methods for MyStruct will find Val specialized properties.\n\n\n\n\n\n","category":"macro"},{"location":"","page":"Home","title":"Home","text":"Here's a trivial, but illustrative example:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using NahaJuliaLib\n\nstruct MyStruct\n    a::Int\nend\n\n@njl_getprop MyStruct\n\nfunction Base.getproperty(o::MyStruct, prop::Val{:b})\n    o.a * 2\nend\n\nms = MyStruct(3)\nMyStruct(3)\n\nms.a\n\nms.b\n\npropertynames(ms)","category":"page"},{"location":"#Tracing-functions","page":"Home","title":"Tracing functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Sometimes when debugging one wants to track the call and return of certain specified functions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@trace\nanalyze_traces\nshow_trace","category":"page"},{"location":"#NahaJuliaLib.@trace","page":"Home","title":"NahaJuliaLib.@trace","text":"@trace(global_flag, definition)\n\nCause the call arguments and return values of the function defined by definition to be logged if global_flag is true at run time. definition should define a method.\n\n\n\n\n\n","category":"macro"},{"location":"#NahaJuliaLib.analyze_traces","page":"Home","title":"NahaJuliaLib.analyze_traces","text":"analyze_traces(log::VectorLogger)\n\nGiven a log containinig log records produced by @trace, return a vector of TraceRecords.  Each of those TraceRecords is the root of a tree of TraceRecords that represent the call tree.\n\nUse show_trace to print the call hierarchy in a human readable form.\n\n\n\n\n\n","category":"function"},{"location":"#NahaJuliaLib.show_trace","page":"Home","title":"NahaJuliaLib.show_trace","text":"show_trace(trace::TraceRecord)\n\nPrint the specified TraceRecord hierarchy in a human readable form.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"using Logging\nusing VectorLogging\nusing NahaJuliaLib\n\n@trace(trace_hanoi,\n       function hanoi(from, to, other, count)\n           if count == 0\n               return nothing\n           else\n               hanoi(from, other, to, count - 1)\n               println(\"move 1 from $from to $to\")\n               hanoi(other, to, from, count - 1)\n               return (from, to)   # arbitrary result to show\n           end\n       end\n       )\n\ntrace_hanoi = true\n\nlogger = VectorLogger()\n\nwith_logger(logger) do\n    hanoi(:a, :b, :c, 3)\nend\n\nbegin\n    traces = analyze_traces(logger)\n    show_trace(traces[1])\nend\n\n","category":"page"}]
}
